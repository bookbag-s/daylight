{"version":3,"file":"extension.js","mappings":"uuBAOA,oBAAyBA,GACxB,MAAMC,EAASC,EAAOC,UAAUC,iBAAiB,qBAI3CC,EAAWJ,EAAOK,IAAI,YACtBC,EAAQN,EAAOK,IAAI,SACnBE,EAAYC,OAAOC,KAAKL,GAgC9BH,EAAOC,UAAUQ,kBAAiBC,MAAOC,IACxCA,EAAEC,MAAMC,SAAQC,GAhCjBJ,eAA0BI,GACzB,MAAMC,EAAOD,EAAKC,KACZC,EAAKhB,EAAOC,UAAUe,GAC5B,GARO,KAQc,IAAAC,cAAaF,IAAO,OARdhB,EAAOK,IAAI,aAQO,CAC5C,MAAMc,EAAQH,EAAKI,YAAY,KACzBC,EAAUL,EAAKM,MAAM,EAAGH,GACxBI,EAAatB,EAAOuB,IAAIT,KAAKM,GAC7BI,GAAgB,IAAAC,kBAAiBL,GACvCM,EAASC,IAAI,WAAYH,EAAc,GAAGI,cAAgBJ,EAAcH,MAAM,IAC9Ef,EAAUO,SAASgB,IAClBC,EAAQH,IAAIE,GAAU,KACrB,IAAIE,EAAa5B,EAAS0B,GAM1B,OALAtB,OAAOC,KAAKH,GAAOQ,SAAQmB,IAC1B,IAAIC,EAAUP,EAASQ,IAAI7B,EAAM2B,IAASN,EAAStB,IAAIC,EAAM2B,IAAU3B,EAAM2B,GAC7EG,QAAQC,IAAI,OAAQJ,EAAMC,GAC1BF,EAAaA,EAAWM,QAAQ,IAAIC,OAAON,EAAM,KAAMC,EAAQ,IAEzDF,CAAU,GAChB,UAEGf,EAAGuB,OAAOzB,EAAMQ,GACtBhB,EAAUO,SAAS2B,IAClB,MAAMC,EAAUzC,EAAOuB,IAAImB,SAASpB,EAAYkB,GAChD,IAAIG,EAAO,GACRb,EAAQI,IAAIM,KACdG,EAAOb,EAAQ1B,IAAIoC,EAAZV,MAAyB,IAEjCd,EAAG4B,UAAUH,EAASI,OAAOC,KAAKH,GAAM,GAE1C,CACD,CAEuBI,CAAWjC,IAAM,GAEzC,EAGA,wBAA8B,EApD9B,kBACA,SACA,SAEMgB,EAAkC,IAAIkB,IAEtCtB,EAA+B,IAAIsB,G,+DCFzC,4BAAiCjC,GAC7B,OAAOA,EAAKkC,MAAM,KAAKC,OAAS,IACpC,C,+DCHA,wBAA6BnC,GACzB,MAAMG,EAAQH,EAAKI,YAAY,KAC/B,OAAc,IAAXD,EACQ,KAEAH,EAAKM,MAAMH,EAAM,EAEhC,C,UCVAiC,EAAOC,QAAUC,QAAQ,S,GCCrBC,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,CAAC,GAOX,OAHAQ,EAAoBH,GAAUI,KAAKV,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,OACf,CCnB0BI,CAAoB,K","sources":["webpack://createformatefile/./src/extension.ts","webpack://createformatefile/./src/utils/getDirectoryName.ts","webpack://createformatefile/./src/utils/getExtension.ts","webpack://createformatefile/external commonjs \"vscode\"","webpack://createformatefile/webpack/bootstrap","webpack://createformatefile/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport { getExtension } from './utils/getExtension';\nimport { getDirectoryName } from './utils/getDirectoryName';\n\nconst tempMap:Map<string, ()=>string> = new Map(); \n\nconst aliasMap:Map<string, string> = new Map(); \nexport function activate(context: vscode.ExtensionContext) {\n\tconst config = vscode.workspace.getConfiguration(\"createFormateFile\");\n\tfunction isTargetExtension(extension:string):boolean{\n\t\treturn `.${extension}` === config.get(\"extension\");\n\t}\n\tconst template = config.get(\"template\") as Record<string, string>;\n\tconst alias = config.get(\"alias\") as Record<string, string>;\n\tconst fileNames = Object.keys(template);\n\tasync function createFile(file:vscode.Uri){\n\t\tconst path = file.path;\n\t\tconst fs = vscode.workspace.fs;\n\t\tif(isTargetExtension(getExtension(path)??\"\")){\n\t\t\tconst index = path.lastIndexOf(\".\");\n\t\t\tconst DirPath = path.slice(0, index);\n\t\t\tconst newFileUri = vscode.Uri.file(DirPath);\n\t\t\tconst directoryName = getDirectoryName(DirPath)!;\n\t\t\taliasMap.set(\"#dirName\", directoryName[0].toUpperCase() + directoryName.slice(1));\n\t\t\tfileNames.forEach((fileName)=>{\n\t\t\t\ttempMap.set(fileName, ()=>{\n\t\t\t\t\tlet contentStr = template[fileName]\n\t\t\t\t\tObject.keys(alias).forEach(item=>{\n\t\t\t\t\t\tlet dirname = aliasMap.has(alias[item]) ? aliasMap.get(alias[item])! : alias[item];\n\t\t\t\t\t\tconsole.log(\"item\", item, dirname)\n\t\t\t\t\t\tcontentStr = contentStr.replace(new RegExp(item, \"g\"), dirname);\n\t\t\t\t\t});\n\t\t\t\t\treturn contentStr;\n\t\t\t\t})\n\t\t\t})\n\t\t\tawait fs.rename(file, newFileUri);\n\t\t\tfileNames.forEach((name)=>{\n\t\t\t\tconst sonPath = vscode.Uri.joinPath(newFileUri, name);\n\t\t\t\tlet temp = \"\";\n\t\t\t\tif(tempMap.has(name)){\n\t\t\t\t\ttemp = tempMap.get(name)?.() ?? \"\";\n\t\t\t\t}\n\t\t\t\tfs.writeFile(sonPath, Buffer.from(temp));\n\t\t\t});\n\t\t}\n\t}\n\tvscode.workspace.onDidCreateFiles(async (e)=>{\n\t\te.files.forEach(file=>createFile(file))\n\t})\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n","/**\r\n * 获取路径的最后一个名称\r\n */\r\n\r\nexport function getDirectoryName(path:string):string|null{\r\n    return path.split(\"/\").pop() ?? null;\r\n}","/**\r\n * 返回文件扩展名\r\n */\r\nexport function getExtension(path:string):string|null{\r\n    const index = path.lastIndexOf(\".\");\r\n    if(index === -1){\r\n        return null;\r\n    }else{\r\n        return path.slice(index+1);\r\n    }\r\n}","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","config","vscode","workspace","getConfiguration","template","get","alias","fileNames","Object","keys","onDidCreateFiles","async","e","files","forEach","file","path","fs","getExtension","index","lastIndexOf","DirPath","slice","newFileUri","Uri","directoryName","getDirectoryName","aliasMap","set","toUpperCase","fileName","tempMap","contentStr","item","dirname","has","console","log","replace","RegExp","rename","name","sonPath","joinPath","temp","writeFile","Buffer","from","createFile","Map","split","pop","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}