### 对象
1. 函数的原型可不可以为null或者undefiend或者其他原始值？
2. 如果一个函数需要一个对象作为参数，且会修改该对象，但是传递的对象不能被修改，怎么办？
3. 对象分为哪三类？属性分为哪两类？
4. 对象的属性具备哪些特性？
5. 什么是原型链？
6. 创建对象的方式有哪些？
7. 对象是什么？（开放题型）
8. 访问对象属性的方法有哪些（两种）？有什么区别？
9. 访问对象的属性错误有哪些（一种）？设置对象的属性不成功有哪些情况（三种）？
10. 如何删除对象的属性，效果是怎样的？
11. 什么情况下删除对象的属性会报错？可以删除全局对象的属性吗？
12. 删除运算符的操作目标是什么？不满足操作目标会怎么样？
13. 如何判断对象是否具有某个属性？如何判断属性是自有属性和继承属性？如何获取所有的自有属性？如何获取可枚举的自有属性？
14. 如何遍历对象的属性？如何遍历可枚举的自有属性？如何便利所有的自有属性？
15. 自有属性和访问器属性有什么区别？
16. 对象的属性由哪些部分构成？
17. 如何获取属性的属性描述符？如何设置属性的描述符？设置属性的属性描述符是，属性特性的默认值是什么？
18. 属性设置为不可配置会发生什么？
19. 默认情况下自定义的属性的属性描述符是什么？
20. 实现浅复制提交到公共函数库？
21. 对象的三个特性是什么？
22. 如何获取对象的原型？__proto__是什么且有什么问题？this.constructor.prototype === this的原型吗？
23. 如何获取对象的类型？对象的类属性是什么？对象字面量，Object.create，new 创建的对象的类属性是什么？内置对象，宿主环境对象的类属性又是什么？
24. 如何使得一个对象不可扩展（3种方式）？这些方式有什么区别以及如何检测？
25. 如何序列化和反序列化一个对象？
26. JSON.stringify存在什么问题，第二个参数是干嘛的？
27. 如何一个对象具有toJSON方法会对JSON.parse有什么影响？
28. valueOf和toString的区别是什么？
29. 如何设置toString的返回值？
30. 获取一个对象的存取器属性的set函数？
### 函数
1. 创建函数的方式有哪些？
2. 函数声明和函数表达式有什么区别？
3. 函数名可以重新赋值吗？
4. 函数的执行上下文中，会自动添加哪些属性（3个）？
5. 箭头函数和普通函数有什么区别？
6. 函数的参数在内部的表现形式是什么？argument和命名参数的区别？
7. 严格模式下argument会有什么变化？
8. 在函数内部除了通过函数名还能怎样得到函数的引用，严格模式下是否适用？
9. 得到函数名称，匿名函数的名称是什么？通过Function创建的函数的名称是什么？匿名函数赋值以后，通过变量获取name又是什么？
10. 如何判断函数是否在全局上下文中执行？如何判断函数执行时所处的执行上下文（两种方式），严格模式是否适用？
11. 如何判断函数是否是通过bind返回的，或者是否为存储器属性的get和set方法？
12. const a = {b(){console.log(this)}}, 请问（a.b = a.b）()，this指向什么？
13. argument如果遇到剩余参数会不会受到影响？
14. argument和实参，形参的关系？
15. 默认参数在什么时候生效？如果传递的值为undefiend会不会生效？如果默认值存在语法错误，什么时候js引擎不会报错？
16. 形参默认值存不存在暂时性死区？
17. 函数声明作为值时，还存不存在声明提升？
18. 如果函数的函数名重新赋值了，函数的名称是否会发生变化？
19. 函数永远无法直接访问外层函数的哪些变量？为什么？
20. 如何判断一个函数是不是通过new来调用的？
21. 可不可以通过new来调用对象的方法？为什么？
22. 可不可以通过new来调用call，apply, bind方法为什么？
23. 每一个函数都具有哪些自有属性（5个）？
24. f.length 如何处理剩余参数的？
25. 剩余参数的位置有什么要求？可以有多个剩余参数吗？
26. 函数声明被小括号包裹以后，会发生什么？答：会被当做函数表达式，函数不会挂载到当前作用域中，自然也就没有变量提升，在当前作用域中，函数名称没有任何作用。
27. 立即执行函数（IIFE）是什么？答：就是一个函数在被创建出来以后就立即调用，主要用于创建局部作用域。
### promise
1. 一个promise可以多次调用then和catch吗？调用以后状态如何判断？
	可以，每一个then和catch都有自己的Promise不会共享
2. 创建Promise是resolve一个promise或者具有then方法的对象会发生什么？
	回调用Promise的then传入自己的resolve,reject,等它来完善自身。
3. 创建Promise是reject一个promise或者具有then方法的对象会发生什么？
	会直接将Promise的状态置为拒觉，值就是传入的Promise或者对象
4. then方法返回一个promise会发生什么？
	仍然会返回新的Promise，只不过Promise的状态和数据都和返回的Promise一致
5. 如何判断一个对象是否为promise？
6. await 后面不是promise怎么处理？
7. await 后面跟上具有then方法的对象会发生什么？
	等效于 Promise.resolve({then(res, rej){}})
8. Promise.resolve的表现形式有哪些？
9. Promise.reject的表现形式？

### 补充
eval的使用

### 模块化
1. 为什么需要模块化？
	当前端项目变大以后，会编写大量的代码，就容易出现名称重复，导致功能出错，尤其是多人协作的时候，A声明的变量和B的冲突了，导致变量没有按照B的要求存储应有的值，从而导致B的逻辑错误，所以为了避免这种情况的出现，就需要模块化，模块化的出现使得某个模块的变量只在该模块中有效，不会自动暴露到全局环境，需要创建者手动暴露，使用者根据需要手动导入，这样就可以避免命名冲突的问题。
2. 模块化标准有哪些？
	commonJS和ESmodule，commonJS是社区标准，仅有nodeJS实现了，浏览器不支持。CommonJS是同步的动态加载的，可以根据需要动态的来导入模块。ESModule是官方的标准，支持异步的动态加载和同步的静态加载，由语法层面来实现，导入的接口和导出该接口的模块的变量，共享一块内存空间，所以具有符号绑定的特点。
	1. ESModule的动态导入：import(模块路径).then((接口)=>{})
3. ESModule的动态导入模块是否存在符号绑定？
	
4. commonJS规范？
	1. 如果一个文件，具有require, exports语句，那么这个文件就是一个模块
	2. 模块当中的变量不会暴露到全局环境
	3. 如果需要暴露接口给调用者，可以通过exports导出，exports是一个空对象，需要暴露的接口，作为exports的属性即可。
	4. 如果想要导入模块的接口，需要使用require函数导入，
5. node是如何实现commonJS模块化的？
	1. 为了避免导入多余的模块，只有到node执行到require函数以后，才会导入相关的模块
	2. 模块的代码在一个函数中运行，避免模块中声明的变量污染全局环境
	3. node会为模块执行的函数，提供exports变量，用于导出接口，实际上模块导出的是module.exports, exports初始具有module.exports的引用。
	4. require函数模块具有缓存，同一个模块不会重复导入，只会返回上一次导入的结果。可以修改导出的结果。

6. 符号绑定是什么？
	ES模块化导出的接口和导入的接口不是值的复制，他们会共享一块内存空间，修改了一边，另外一边也会修改。
7. ES6模块化？
	1. 导入的模块路径必须是相对路径
	2. 具有基本导入导出和默认导入导出两种方式导入导出模块
	3. 采用依赖预声明的方式导入模块
		1. 所以的导入语句必须位于其他代码之前。（浏览器的容错，不位于最前面也可以，会自动提前到最前面）
		2. commonJS是依赖延迟声明
			1. 如果依赖是动态的，性能优于依赖预声明
			2. 无法一开始就确定模块的依赖关系
		3. 依赖预声明：
			1. 优点：一开始就可以知道模块的依赖关系
			2. 如果依赖是动态的，效率较低
8. 浏览器实现ES模块化的注意点？
	1. 导出的接口是不可变的
	2. 为了兼容以前的代码，如果导入的文件是模块，那么script语句的type属性必须设置为module
	3. 如果一个模块具有import语句，那么模块的代码必须等待依赖的模块加载完成以后，才会运行
	4. ES6的模块化也具备缓存功能，同一个模块不会运行多次。
	5. 文件的后缀名必须添加
9. ES6能导出匿名函数吗？
### 设计
1. 弹窗怎么实现？需要解决哪些问题？怎么解决？
	1. 如何避免被其他元素遮挡？
	2. 多次弹窗怎么处理？
### 事件循环
	事件循环是一种代码运行的方式，js代码是由渲染主线程运行的，当渲染主线程执行完同步代码以后，会进入一个死循环。每次循环都会检查消息队列是否有任务需要执行，如果有就取出任务运行。没有就进入休眠状态，等待消息队列中加入任务。其他线程可以在任何时候向消息队列中加入任务，如果渲染主线程处于休眠状态，那么会唤醒主线程，执行任务。	


### 问题（16天解决）
1. 包含块是什么？√
2. css的属性计算过程？√
	一个元素要渲染到屏幕上，那么这个元素必须具有所有的css属性值。
	1. 确定声明值，确定作者样式表和浏览器默认样式表中没有冲突的css属性值
	2. 层叠：根据重要性，权重以及源码顺序，确定要使用的css属性
		1. 比较重要性：!important的作者样式 > !important的浏览器默认样式 > 作者样式 > 浏览器默认样式
		2. 权重：行内样式权重为1000，id权重100， 类，伪类，属性选择器权重10，元素，伪元素权重为1，*权重为0 
	3. 继承：比如color，font-size等，如果上面两部都没有确定这些属性值，那么能继承的就使用继承值
	4. css的默认值
3. 层叠上下文？√
4. line-height,vetical-align是如何生效的？
5. 定位的依据是什么？相对定位是相对于谁？都是相对于包含块，只不过不同的定位元素，包含块不同
6. react的原理？
7. 浏览器渲染流程是这样的？√
8. 模块化 √
9. ts如何处理模块化 √
10. webpack的渲染流程 √
11. webpack优化
12. 隐私类型转化
13. async，await的原理
14. node的事件循环 ×
15. 网格布局 √
2015年ES6发布



